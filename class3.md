# 第三课：继续完善游戏基础场景模版

## 第一步： 定义一个变量
作为一个未来的程序员，你的程序里面会有很多“数”，每个数在执行的过程中还会经常变化。因此，你想要在一个巨大的工程里清晰的知道这个数在从头到尾都在做什么，最好的方法就是把这个数定义成<b>“变量”</b>。变量之所以叫“变”就是因为它一直会变化，但是我们又希望有个名字来随时准确的使用它。实际上对应“变量”还有一个叫“常量”的家伙，它就是不变的。（顺便解释一下，在上一节课中你定义的变量为什么都用大写，而这里都用小写呢，这其实是个程序猿之间的小默契。上一课中我们建立的 WIDTH 这样的变量，很多时候我们是不想变动它的，因为一个窗口的宽度在加载之后我们很少再变动它。所以我们把它写成全大写，代表这个变量在我的心里其实是个‘常量’是一个不太会变的变量的意思。）在接下来的这一段程序里，我们打算定一个变量来表示我的程序究竟打算继续执行，还是打算结束掉去做其它事情。你之前的程序没有向你展示任何内容就退出了不是吗？那是因为你没有告诉它要做什么！接下来我们就做这件事。在 `pygame.quit()` 的上一行写下如下代码，记得 `#`是什么意思吧，他只是一个说明，不参加运行。
```
# 定义程序是否继续执行
running = True
```
你看这里也用了“#”这个标注，他不参与执行，但用来告诉自己我在这里为什么要这样做。当然当你的程序转给别人看的时候，它也用于告诉其它使用你的代码的人，我为什么这么写。
<br>现在我们定义了一个变量叫做`running`，我刚才说过变量其实是一些数，但是这里为什么叫 `True` 呢。 这是因为 ‘True’ 就是真正的常量，因为它是不允许你更改的。在大多数程序编译器里都有这样一个“常量”来代表‘对的’这个概念，而且是默认定义的不需要你自己来定义的，很多时候不允许你来定义的。Ture的值大多时候就是‘1’，对应的还有一个‘False’，你一会就会用到。它大多时候都是‘0’，这个值在不同的程序语言里其实并不固定，但是每种程序语言一定都会预留这样的常量，好让写程序的人不用考虑它门真的是什么值，而只是明确的知道自己可以用 Ture 来表示对的、是的、真的。用 False 来表示错的、假的、不对的、不是这样的。
<br>这里让 running = True 的意思就是对程序说：从现在起，我的程序的状态就是 `running` ，我不告诉你结束，running 的状态还是 True，你就一直执行下去。在下一步中，你就会用到这个重要的概念。

## 第二步： 建立一个永远执行的循环
如果我们想让上节课中定义的窗口真的显示出来，其实我们要一直让它干点什么事，如果它认为自己的事情干完了，就会继续向下执行程序里的后面的语句，直到执行到程序结束。所以程序是永远不会闲下来的，而且也没有自己执行下去的程序，包括你看到电脑上的各种窗口。如果你在程序里没有看到它在执行什么，那么一定是它在后台程序的什么地方写了一个类似下面的这样一个循环。在你的程序结束前加入下面这段代码。
```
while running:
    # 在这里等待 pygame 这个库已经定义好的各种事件的发生
    for event in pygame.event.get():
        # 在这里判断是否发生了由 pygame 这个库已经定义好的一个事件 QUIT
        if event.type == pygame.QUIT:
            #在这里把我们自己定义的继续执行这个标志变量变成‘不是’‘不要’‘不’
            running = False
```
这里一下用了2个循环和一个判断，他们被叠加在一起。这是我们写程序最常用的手段，来完成各种复杂的逻辑。
### while
`while`的意思是一直执行下面的内容，直到`while`后面的值是 False 才结束。在python程序中，while的后面是没有一个结束标志的，这是因为它会把`while`后面所有比他‘靠右’的代码都当作是他要不断执行的内容。不管你在后面加了‘空格’加了‘tab’等待让代码前面空置的部分比'while'多，它就会把它们都算在`while`的管辖范围。`while`会不断的把它管辖范围内的代码一直执行，直到你在他的后面加个 False 才结束。但是你看到我们在这里用的不是 False 也不是 True，而是running，为什么呢？这是因为running是变量，是可以变的！我们迟早会让 running 变成 False，当它变成 False 的时刻，就是我们希望 while 结束的时候。

### for
`for` 的意思是，如果 for ‘什么’ in ‘什么，什么’ : 只要后面这个‘什么什么’所代表的"数组"里还有数没用过，就将这个数放到前面的‘什么’这个变量里，然后执行`for`所管辖的所有代码。`for`的管辖范围和前面讲的`while`的管辖范围判断形式是一致的，只要后面比它靠右就被它管辖，直到出现第一个比它靠左的家伙出现，它就不在管辖了。数组还记得么？在上一节课曾经讲到过的，用一个名字代表一堆数，这个名字就叫一个“数组”。
<br>在这里for event in pygame.event.get() 的意思是：我向 pygame 这个库里面的 event这个属性里，用get()这个方法，向pygame要所有的它现有的 ‘event’ 事件信息。这里提到了“属性”和“方法”。如果希望更详细的理解，可以到这节课结束动作里去了解更多。在这里你只要直到，通过这个 get() 可以把 pygame 存在 event 里的所有事件都拿出来，交给 `for` 来执行，for会把每一个事件都放到 event 这个变量里，让后面的代码不断执行。这个单独的 event 和 pygame.event 是完全不相干的两个东西，event是我们这段程序自己的变量。而pygame.event 因为有个'.'所以代表那个event属于pygame。我们代码里为了能够更好的理解，特意把他们写成一样的名字，让大家知道我从 pygame要过来的是事件event。而处理的是这些事件event里的每一个event。其实你把它命名成其它名字，在`for`后面的程序里都用同样的名字，我们的程序执行结果不会有任何改变。你可以试一试哦。

### if
`if`代表了如果，如果 if 后面的这个结果是 Ture 是真的，那么我就执行管辖范围的代码，而如果是 False 则不执行管辖范围内的代码，直接跳过去，执行后面的内容。 `if` 的后面其实只有 Ture 或 False ，但为什么我们在这里放了一个 event.type == pygame.QUIT: 呢，这是因为这里用到的 ‘==’ 代表了比较。 ‘==’ 两边的值一样，‘==’判断的结果就返回 True ，不一样就返回 False。 这样`if`就知道了后面的代码要不要执行。 event 其实不是一个数，是一个结构，我们用event变量接收了一个放在 pygame.event 数组里面的 event。每个event其实还包含很多其它的属性。而这里我们只用 type （类型）这个属性。因此我们用 event.type 把这个值准确的找出来。同时 pygame 里为了大家使用清晰，把各种event类型都定义成常量，并给它一个好理解的名字，例如 QUIT 这个名字，它代表着这个事件类型是退出事件。这样大家都可以很简单的使用了。其实翻译过来这句话的意思是，检查一下，我当前拿到的这个事件 （event） ，他的事件类型（type）是不是退出事件（QUIT），如果是就执行后面的 running = False 。如果不是，那么就不执行，而 running 呢，就还是 True。这给后就又涉及到这个程序的总控制部分了。还记得现在咱们看到的这些都在 `while` 的总管辖范围吗？这里只要把 running 的值变成了 False，程序执行完就会回到`while`那里，`while`发现了这个变化就会跳出执行，执行`while`后面的代码，并执行到最后的退出程序，pygame.exit()。

## 第三步：执行程序与调试执行
### 执行程序
有了完整的程序，你就可以执行它了。我们现在能够看到，在你写的程序的整个窗口的右上角有一个绿色的三角，它代表执行，只要点击它，VSCode 这个工具就会调用 python 的执行命令，将你写好的程序按照规则执行一遍。当前执行的效果就是会出现一个可爱的窗口，只要你不去点击左上或右上角关闭的‘X’按钮，它就会一直在这里。现在可以去点绿三角了。

### 调试执行
很多时候，作为一个程序员，你会需要查看执行背后的逻辑。那么你现在可以尝试使用 VSCode 的调试执行功能了。看看VSCode最左边的一列按钮，其中有一个是三角形上有一个。

## 第四步：结束窗口，退出你的游戏


## 结束动作：别忘了把今天的工作放到Github上
参考第一课中的[结束动作](./FirstClass.md)将今天完成的程序也放到Github上。

## 回顾一下这一课都做了什么吧
### 理解一下属性与方法

## [下一课，第三课](./class3.md)
## [回到主课程](./README.md)
